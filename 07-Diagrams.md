

# Diagrams

####Note:  this chapter isn't copy-edited yet, so there's no need to file issues for things like spelling mistakes.

In this chapter, we'll look at a functional way to describe diagrams, and how to draw them with Core Graphics. By wrapping Core Graphics with a functional layer, we get an API that's simpler and more composable.


## Drawing squares and circles

Imagine drawing the following diagram:

![](generated/example1.pdf)

In Core Graphics, we could achieve this drawing with the following command:

```objectivec
[[NSColor blueColor] setFill]
CGContextFillRect(context, CGRectMake(0.0,37.5,75.0,75.0))
[[NSColor redColor] setFill]
CGContextFillRect(context, CGRectMake(75.0,0.0,150.0,150.0))
[[NSColor greenColor] setFill]
CGContextFillEllipseInRect(context, CGRectMake(225.0,37.5,75.0,75.0))
```

This is nice and short, but it is a bit hard to maintain. For example, what if we wanted to add an extra circle:

![](generated/example2.pdf)

We would need to add the code for drawing a rectangle, but also update the drawing code to move some of the other objects to the right.  In Core Graphics, we always describe *how* to draw things. In this chapter, we'll build a library for diagrams that allows us to express *what* we want draw. For example, the first diagram can be expressed like this:

```swift
let blueSquare = square(side: 1).fill(NSColor.blueColor())
let redSquare = square(side: 2).fill(NSColor.redColor())
let greenCircle = circle(radius: 1).fill(NSColor.greenColor())
let example1 = blueSquare ||| redSquare ||| greenCircle
```

And adding the second circle is as simple as changing the last line of code:

```swift
let example2 = blueSquare ||| circle(radius: 1).fill(NSColor.cyanColor()) ||| redSquare ||| greenCircle
```

The code above first describes a blue square, with a relative size of 1. The
red square is twice as big (it has a relative size of 2), and we compose the
diagram by putting the squares and the circle next to each other with the `|||`
operator. Changing this diagram is very simple, and there's no need to worry
about calculating frames or moving things around. The examples describe *what*
should be drawn, not *how* it should be drawn.

One of the techniques we'll use in this chapter is building up an intermediate
structure of the diagram. Instead of executing the drawing commands immediately, we build
up a data structure that describes the diagram. This is a very powerful
technique, as it allows us to inspect the data structure, modify it and convert
it into different formats.

As a more complex example of a diagram generated by the same library, here's a bar graph:

![](generated/example3.pdf)

We can write a `barGraph` function that takes a list of names (the keys) and
values (the relative heights of the bars). For each value, we draw a rectangle,
and horizontally concatenate them with the `hcat` function. For each name, we
draw it as text, also horizontally concatenate them using `hcat`, and finally put the bars
and the text below each other using the `---` operator:

```swift
func barGraph(input: [(String,Double)]) -> Diagram {
    let values : [CGFloat] = input.map { CGFloat($0.1) }
    let bars =  hcat(normalize(values).map { (x: CGFloat) -> Diagram in
        return rect(width: 1, height: 3*x).fill(NSColor.blackColor()).alignBottom()
    })
    let labels = hcat(input.map { x in
        return text(width: 1, height: 0.3, text: x.0).fill(NSColor.cyanColor()).alignTop()
    })
    return bars --- labels
}
let cities = ["Shanghai": 14.01, "Istanbul": 13.3, "Moscow": 10.56, "New York": 8.33, "Berlin": 3.43]
let example3 = barGraph(cities.keysAndValues)
```

## The Core Data Structures

In our library, we'll draw three kinds of things: ellipses, rectangles and text. Using enums, we can define a datatype for that:

```swift
enum Primitive {
    case Ellipsis
    case Rectangle
    case Text(String)
}
```

It would be very possible to extend this with other primitives, such as images or more complex shapes.

Diagrams are defined using an enum as well. First, a diagram could be a primitive, which has a size and is either an ellipsis, a rectangle or text. Note that we call it `Prim` because, at the time of writing, the compiler gets confused by a case that has the same name as another enum. 

```swift
case Prim(CGSize, Primitive)
```

Then, we have cases for diagrams that are beside each other (horizontally) or below each other (vertically). Note how a `Beside` diagram is defined recursively: it consists of two diagrams next to each other.

```swift
case Beside(Diagram,Diagram)
case Below(Diagram,Diagram)
```

To style diagrams, we'll add a case for attributed diagrams. This allows us to set the fill color (for example, for ellipses and rectangles). We'll define the `Attribute` type later.

```swift
case Attributed(Attribute,Diagram)
```

The last case is for alignment. Suppose we have a small and a large rectangle that are next to each other. By default, the small rectangle gets centered vertically:

![](generated/example4.pdf)

But by adding a case for alignment we can control the alignment of smaller parts of the diagram. 

```swift
case Align(Vector2D, Diagram)
```

For example, here's a diagram that's top-aligned:

![](generated/example5.pdf)

It is drawn using the following code:

```swift
Diagram.Align(Vector2D(x: 0.5,y: 1), blueSquare) ||| redSquare
```

Unfortunately, in the current version of Swift, recursive datatypes are not allowed. So instead of having a `Diagram` case that contains other `Diagram`s, we created an extra protocol `DiagramLike`, and change our `Diagram` definition accordingly:

```swift
enum Diagram {
    case Prim(CGSize, Primitive)
    case Beside(DiagramLike, DiagramLike)
    case Below(DiagramLike, DiagramLike)
    case Attributed(Attribute, DiagramLike)
    case Align(Vector2D, DiagramLike)
}
```

The `DiagramLike` protocol has just one function, and only one instance:

```swift
protocol DiagramLike { func diagram() -> Diagram }

extension Diagram: DiagramLike {
  func diagram() -> Diagram { return self }
}
```

The `Attribute` enum is a datatype for describing different attributes of diagrams. Currently, it only supports `FillColor`, but it could easily be extended to support attributes for stroking, gradients, text attributes, etcetera:

```swift
enum Attribute {
    case FillColor(NSColor)
}
```

## Calculating and Drawing

Calculating the size for the `Diagram` datatype is easy. The only case that's not straightforward is for `Beside` and `Below`. In case of beside, the width is equal to the sum of the widths, and the height is equal to the maximum height of the left and right diagram. For below, it's a similar pattern. For all the other cases we just call size recursively.

```swift
extension Diagram {
  var size : CGSize {
    switch self {
      case .Prim(let size, _):
        return size
      case .Attributed(_, let x):
        return x.diagram().size
      case .Beside(let l, let r):
        let sizeL = l.diagram().size
        let sizeR = r.diagram().size
        return CGSizeMake(sizeL.width+sizeR.width,max(sizeL.height,sizeR.height))
      case .Below(let l, let r):
        let sizeL = l.diagram().size
        let sizeR = r.diagram().size
        return CGSizeMake(max(sizeL.width,sizeR.width),sizeL.height+sizeR.height)
      case .Align(_, let r):
        return r.diagram().size
    }
  }

}
```



Before we start drawing, we will first define one more function. The `fit` function takes an alignment vector (which we used in the `Align` case of a diagram), an input size (i.e. the size of a diagram) and a rectangle that we want to fit the input size into. The input size is defined relatively to the other elements in our diagram. We scale it up, and maintain its aspect ratio.

```swift
func fit(alignment: Vector2D, inputSize: CGSize, rect: CGRect) -> CGRect {
    let div = rect.size / inputSize
    let scale = min(div.width, div.height)
    let size = scale * inputSize
    let space = alignment.size * (size - rect.size)
    let result = CGRect(origin: rect.origin - space.point, size: size)
    return result
}
```

For example, if we fit and center square of 1x1 into a rectangle of 200x100, we get the following result:

```
fit(Vector2D(x: 0.5, y: 0.5), CGSizeMake(1,1), CGRectMake(0,0,200,100))

> (50.0,0.0,100.0,100.0)
```

To align the rectangle to the left, we would do the following:

```
fit(Vector2D(x: 0, y: 0.5), CGSizeMake(1,1), CGRectMake(0,0,200,100))

> (0.0,0.0,100.0,100.0)
```

Now that we can represent diagrams and calculate their sizes, we're ready to draw them. We use pattern matching to make it easy to know what to draw. The `draw` method takes a couple of parameters: the context to draw in, the bounds to draw in and the actual diagram. Given the bounds, the diagram will try to fit itself into the bounds using the `fit` function defined before. For example, when we draw an ellipse, we center it and make it fill the available bounds: 

```swift
func draw(context: CGContextRef, bounds: CGRect, diagram: Diagram) {
  switch diagram {
    case .Prim(let size, .Ellipsis):
      let frame = fit(Vector2D(x: 0.5, y: 0.5), size, bounds)
      CGContextFillEllipseInRect(context, frame)
```

For rectangles, this is almost the same, except that we call a different Core Graphics function. You might note that the `frame` calculation is the same as for ellipses. It would be possible to pull this out and have a nested switch statement, but we think is is more readable when presenting in book-form.

```swift
    case .Prim(let size, .Rectangle):
        let frame = fit(Vector2D(x: 0.5, y: 0.5), size, bounds)
        CGContextFillRect(context, frame)

```

In the current version of our library, all text is set in the system font with a fixed size. It's very possible to make this an attribute, or change the `Text` primitive to make this configurable. In its current form though drawing text works like this:

```swift
    case .Prim(let size, .Text(let text)):
        let frame = fit(Vector2D(x: 0.5, y: 0.5), size, bounds)
        let attributes = [NSFontAttributeName: NSFont.systemFontOfSize(12)]
        let attributedText = NSAttributedString(string: text, attributes: attributes)
        attributedText.drawInRect(frame)
```

The only attribute we support is fill color. It's very easy to add support for extra attributes, but we left that out for brevity. To draw a diagram with a `FillColor` attribute, we save the current graphics state, set the fill color, draw the diagram and finally restore the graphics state:

```swift
    case .Attributed(.FillColor(let color), let d):
        CGContextSaveGState(context)
        color.set()
        draw(context, bounds, d.diagram())
        CGContextRestoreGState(context)

```

To draw two diagrams next to each other, we first need to find their respective frames. We created a function `splitHorizontal` that splits a `CGRect` according to a ratio (in this case, the relative size of the left diagram). Then we draw both diagrams with their frames.

```swift
    case .Beside(let left, let right):
        let l = left.diagram()
        let r = right.diagram()
        let (lFrame, rFrame) = splitHorizontal(bounds, l.size/diagram.size)
        draw(context, lFrame, l)
        draw(context, rFrame, r)
```

The case for `Below` is exactly the same, except that we split the `CGRect` vertically instead of horizontally. This code was written to run on the Mac, and therefore the order is `bottom` and `top` (unlike UIKit, the Cocoa coordinate system has the origin at the bottom left).

```swift
    case .Below(let top, let bottom):
        let t = top.diagram()
        let b = bottom.diagram()
        let (lFrame, rFrame) = splitVertical(bounds, b.size/diagram.size)
        draw(context, lFrame, b)
        draw(context, rFrame, t)
```

Our last case is aligning diagrams. Here, we can reuse the fit function that we defined earlier to calculate new bounds that fit the diagram exactly.

```swift
    case .Align(let vec, let d):
        let diagram = d.diagram()
        let frame = fit(vec, diagram.size, bounds)
        draw(context, frame, diagram)
  }
}
```

We've now defined the core of our library. All the other things can be built on top of these primitives.

## Creating Views and PDFs

We can create a subclass of `NSView` that performs the drawing, which is very
useful when working with playgrounds or when you want to draw these diagrams in
Mac applications.:

```swift
class Draw : NSView {
    let diagram: Diagram

    init(frame frameRect: NSRect, diagram: Diagram) {
        self.diagram = diagram
        super.init(frame:frameRect)
    }

    override func drawRect(dirtyRect: NSRect) {
        draw(NSGraphicsContext.currentContext().cgContext, self.bounds, diagram)
    }
}
```


Now that we have an `NSView`, it's also very simple to make a PDF out of our diagrams. We calculate the size and just use `NSView`s method `dataWithPDFInsideRect` to get the PDF data.

```swift
func pdf(diagram: Diagram, width: CGFloat) -> NSData {
    let v : Draw = {
        let unitSize = diagram.size
        let height = width * (unitSize.height/unitSize.width)
        return Draw(frame: NSMakeRect(0, 0, width, height), diagram: diagram)
    }()
    return v.dataWithPDFInsideRect(v.bounds)
}
```


## Extra combinators

To make the construction of diagrams easier, it's nice to add some extra functions (also called combinators). This is a common pattern in functional libraries: have a small set of core datatypes and functions, and then build convenience functions on top of that. For example, for rectangles, circles, text and squares we can define convenience functions:

```swift
func rect(#width: CGFloat, #height: CGFloat) -> Diagram {
    return Diagram.Prim(CGSizeMake(width, height), .Rectangle)
}

func circle(#radius: CGFloat) -> Diagram {
    return Diagram.Prim(CGSizeMake(radius, radius), .Ellipsis)
}

func text(#width: CGFloat, #height: CGFloat, text theText: String) -> Diagram {
    return Diagram.Prim(CGSizeMake(width, height), .Text(theText))
}

func square(#side: CGFloat) -> Diagram { 
  return rect(width: side, height: side) 
}
```

Also, it turns out that it's very convenient to have operators for combining diagrams horizontally and vertically, making the code more readable. They are just wrappers around `Beside` and `Below`.

```swift
operator infix ||| { associativity left }
@infix func ||| (l: Diagram, r: Diagram) -> Diagram {
    return Diagram.Beside(l, r)
}

operator infix --- { associativity left }
@infix func --- (l: Diagram, r: Diagram) -> Diagram {
    return Diagram.Below(l, r)
}
```

We can also extend the `Diagram` type and add methods for filling and
alignment. Instead, we might have defined these methods as top-level functions.
This is a matter of style, one is not more powerful than the other.

```swift
extension Diagram {
    func fill(color: NSColor) -> Diagram {
      return Diagram.Attributed(Attribute.FillColor(color), self)
    }
    
    func alignTop() -> Diagram {
        return Diagram.Align(Vector2D(x: 0.5,y: 1), self)
    }
    
    func alignBottom() -> Diagram {
        return Diagram.Align(Vector2D(x:0.5, y: 0), self)
    }
}
```

Finally, we can define an empty diagram and a way to horizontally concatenate a list of diagrams. We can just use the array's `reduce` function to do this.

```swift
let empty : Diagram = rect(width: 0, height: 0)

func hcat(diagrams: [Diagram]) -> Diagram {
    return diagrams.reduce(empty, combine: |||)
}
```

By adding these small helper functions, we have a powerful library for drawing
diagrams. Many things are still missing but can be added easily. For example,
it's straightforward to add more attributes and styling options. A bit more
complicated would be adding transformations (e.g. rotation), but this too is
doable.

[^Monoids]: http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf "Monoids: Theme and Variations (Functional Pearl)"



